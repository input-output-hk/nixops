<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="chap-overview">

<title>Overview</title>

<para>This chapter gives a quick overview of how to use NixOps.</para>

<section><title>Deploying a VirtualBox VM</title>

<para>NixOps deploys machines on the basis of a declarative
description of what those machines should do, and where they should be
deployed to.  These descriptions are specified in the <emphasis>Nix
expression language</emphasis> used by the Nix package manager.  <xref
linkend="ex-logical.nix" /> shows a minimal specification of a network
consisting of only one logical machine named
<literal>webserver</literal>.</para>

<example xml:id="ex-logical.nix">
  <title><filename>trivial.nix</filename>: logical network specification</title>
<programlisting>
{
  network.description = "Web server";

  webserver =
    { config, pkgs, ... }:
    { services.httpd.enable = true;
      services.httpd.adminAddr = "alice@example.org";
      services.httpd.documentRoot = "${pkgs.valgrind.doc}/share/doc/valgrind/html";
      networking.firewall.allowedTCPPorts = [ 80 ];
    };
}
</programlisting>
</example>

<para>This specification consists of a set of top-level attributes
describing logical machines (namely <varname>webserver</varname>) and
meta-information (namely <varname>network.description</varname>).
Each attribute not named <varname>network</varname> describes a
logical machine.  The value of each logical machine attribute is a
<emphasis>NixOS configuration module</emphasis>, which describes the
desired configuration of the corresponding machine.  Thus, the logical
machine <literal>webserver</literal> should have the Apache
<command>httpd</command> web server running, and its document root
(rather arbitrarily for demonstration purposes) should be the
documentation of the Valgrind package.</para>

<para>To deploy this machine, we also need to provide configuration
options that tell NixOps to what environment it should be deployed.
<xref linkend="ex-physical-vbox.nix" /> specifies that
<literal>webserver</literal> should be deployed as a VirtualBox
instance. Note that for this to work the <literal>vboxnet0</literal> network has to exist - you can add it in the VirtualBox general settings under <emphasis>Networks - Host-only Networks</emphasis> if necessary.
If you are running NixOps in a headless environment, then you should also add the option
<code>deployment.virtualbox.headless = true;</code>
to the configuration. Otherwise, VirtualBox will fail when it tries to open a graphical display on the host's desktop.</para>

<example xml:id="ex-physical-vbox.nix">
  <title><filename>trivial-vbox.nix</filename>: VirtualBox physical network specification</title>
<programlisting>
{
  webserver =
    { config, pkgs, ... }:
    { deployment.targetEnv = "virtualbox";
      deployment.virtualbox.memorySize = 1024; # megabytes
      deployment.virtualbox.vcpu = 2; # number of cpus
    };
}
</programlisting>
</example>

<para>Before we can deploy the network we need to use the command
<command>nixops create</command> to create a <emphasis>NixOps
deployment</emphasis> that contains any state associated with the
deployment (such as information about instantiated VMs).  At creation
time, we need to specify the Nix expressions that constitute the
complete deployment specification.  So to create a deployment for
deploying the Apache web server to VirtualBox, we would do:

<screen>
$ nixops create ./trivial.nix ./trivial-vbox.nix -d trivial
33bced96-5f26-11e1-b9d7-9630d48abec1
</screen>

Here <literal>-d trivial</literal> gives the symbolic name
<literal>trivial</literal> to the deployment.  Deployments can be
identified in two ways: using the UUID printed by <command>nixops
create</command>, or using the symbolic name you specified at creation
time.</para>

<para>You can print a list of existing deployments using
<command>nixops list</command>:

<screen>
+--------------------------------------+-----------+--------------+------------+------------+
|                 UUID                 |   Name    | Description  | # Machines |    Type    |
+--------------------------------------+-----------+--------------+------------+------------+
| 33bced96-5f26-11e1-b9d7-9630d48abec1 |  trivial  |  Web server  |     0      |            |
+--------------------------------------+-----------+--------------+------------+------------+
</screen>
</para>

<para>The command <command>nixops info</command> shows the current
deployment state:

<screen>
$ nixops info -d trivial
Network UUID: 33bced96-5f26-11e1-b9d7-9630d48abec1
Network description: Web server

+-----------+--------+------------+-------------+------------+
|   Name    | Status |    Type    | Resource Id | IP address |
+-----------+--------+------------+-------------+------------+
| webserver |  New   | virtualbox |             |            |
+-----------+--------+------------+-------------+------------+
</screen>

The machine status <literal>New</literal> indicates that the logical
machine <literal>webserver</literal> hasn’t been created yet.  The
<option>-d</option> option specifies which deployment to use; you can
use the symbolic name (<literal>-d trivial</literal>) or the UUID
(<literal>-d 33bced96-5f26-11e1-b9d7-9630d48abec1</literal>).  You
can also set the the environment variable
<envar>NIXOPS_DEPLOYMENT</envar>.</para>

<para>The actual deployment is done by running <command>nixops
deploy</command>:

<screen>
$ nixops deploy -d trivial
creating VirtualBox VM ‘webserver’...
Virtual machine 'nixops-33bced96-5f26-11e1-b9d7-9630d48abec1-webserver' is created and registered.
Clone hard disk created in format 'VDI'. UUID: 5a0b0771-7e03-4fab-9c2f-e95888b57db3
Waiting for VM "nixops-33bced96-5f26-11e1-b9d7-9630d48abec1-webserver" to power on...
VM "nixops-33bced96-5f26-11e1-b9d7-9630d48abec1-webserver" has been successfully started.
waiting for IP address of ‘webserver’........................... 192.168.56.101
waiting for SSH on ‘webserver’...
building all machine configurations...
building path(s) `/nix/store/ybrny9h744q8i3x026ccfmdav8qnw7pd-nixos-version'
building path(s) `/nix/store/zxw279xhl6l8yl94gnka8aqv1kkcrrd4-os-release'
fetching path `/nix/store/pn43d3llpsm3pc1ywaxccmw8pmzjqgz0-valgrind-3.7.0'...
…
copying closure to machine ‘webserver’...
copying 376 missing paths to ‘root@192.168.56.101’...
importing path `/nix/store/jfcs9xnfbmiwqs224sb0qqsybbfl3sab-linux-headers-2.6.35.14'
…
activating new configuration on machine ‘webserver’...
updating GRUB 2 menu...
activating the configuration...
…
starting new service ‘httpd’...
</screen>

NixOps performs the following steps to do the deployment:

<itemizedlist>

  <listitem><para>It creates missing machines.  In this case, a
  VirtualBox instance for the logical machine
  <literal>webserver</literal> is started.  NixOps then waits to
  obtain its IP address.</para></listitem>

  <listitem><para>It builds the NixOS machine configurations locally.
  For instance, here Valgrind is built or downloaded because our
  machine configuration has a dependency on it.</para></listitem>

  <listitem><para>It copies the closure of each machine configuration
  to the corresponding machine.</para></listitem>

  <listitem><para>It activates the configuration on each machine.  For
  instance, it starts the <literal>httpd</literal> systemd service on
  the <literal>webserver</literal> machine.  This is the only step
  that has a visible effect; all prior steps do not affect the active
  configuration of the machines.</para></listitem>

</itemizedlist>

</para>

<para>The <command>nixops info</command> command will show that a
machine was created:

<screen>
$ nixops info -d trivial
Network UUID: 33bced96-5f26-11e1-b9d7-9630d48abec1
Network description: Web server

+-----------+--------+------------+-----------------------------------------------------+----------------+
|   Name    | Status |    Type    |                    Resource Id                      |   IP address   |
+-----------+--------+------------+-----------------------------------------------------+----------------+
| webserver |   Up   | virtualbox | nixops-33bced96-5f26-11e1-b9d7-9630d48abec1-machine | 192.168.56.101 |
+-----------+--------+------------+-----------------------------------------------------+----------------+
</screen>

</para>

<para>Visit <literal>http://192.168.56.101</literal> in a web browser
should now show the Valgrind documentation.  You can also log in to
the virtual machine as <literal>root</literal>:

<screen>
$ nixops ssh -d trivial webserver
connecting to 192.168.56.101...
[root@webserver:~]#
</screen>

The command <command>nixops ssh</command> is a convenience wrapper
around <command>ssh</command> that passes the right IP address and SSH
identity for the specified logical machine.  (NixOps automatically
creates a unique SSH key pair for communicating with each VirtualBox
instance.)</para>

<para>Redeployment after making a change to the specification is
simply a matter of running <command>nixops deploy</command> again.  If
we do this for the example, NixOps will notice that the
<literal>webserver</literal> machine already exists and that most or
all dependencies are already present, so it won’t create a new
VirtualBox instance or need to build and copy a lot of dependencies.
Thus redeployment typically only takes a few seconds:

<screen>
$ time nixops deploy -d trivial
building all machine configurations...
copying closure to machine ‘webserver’...
activating new configuration on machine ‘webserver’...
real    0m3.700s
</screen>

</para>

<para>If you want to get rid of the virtual machines created by
NixOps, you can run <command>nixops destroy</command>:

<screen>
$ nixops destroy -d trivial
warning: are you sure you want to destroy VirtualBox VM ‘webserver’? (y/N) y
webserver> destroying VirtualBox VM...
webserver> 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
webserver> 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
</screen>

You can use the option <option>--confirm</option> to confirm all
questions.  This is useful for automated deployment, but potentially
dangerous.</para>



<section><title>Deploying multiple machines</title>

<para>A network consisting of only one logical machine is not very
exciting.  <xref linkend="ex-logical-multi.nix" /> shows a network
consisting of three machines: a load balancer (named
<literal>proxy</literal>) that uses Apache’s
<literal>mod_proxy</literal> to do reverse proxying, and two backend
web servers (<literal>backend1</literal> and
<literal>backend2</literal>) that serve the actual content.  One
important thing to note is that if you want to refer to another
machine (e.g. in a configuration file), you can use a hostname equal
to the logical name of the machine, as in the line

<programlisting>
BalancerMember http://backend1 retry=0
</programlisting>

This works because NixOps generates a <filename>/etc/hosts</filename>
file that contains entries for all the logical machines in the
network, mapping names to each machine’s IP address.  Also note that
because the two backend machines have identical configurations, we can
use a let-binding to define the configuration only once.</para>

<example xml:id="ex-logical-multi.nix">
  <title><filename>load-balancer.nix</filename>: logical network specification</title>
<programlisting>
let

  backend =
    { config, pkgs, ... }:
    { services.httpd.enable = true;
      services.httpd.adminAddr = "alice@example.org";
      services.httpd.documentRoot = "${pkgs.valgrind.doc}/share/doc/valgrind/html";
      networking.firewall.allowedTCPPorts = [ 80 ];
    };

in

{
  network.description = "Load balancing network";

  proxy =
    { config, pkgs, nodes, ... }:
    { services.httpd.enable = true;
      services.httpd.adminAddr = "bob@example.org";
      services.httpd.extraModules = ["proxy_balancer" "lbmethod_byrequests"];
      services.httpd.extraConfig =
        ''
          &lt;Proxy balancer://cluster>
            Allow from all
            BalancerMember http://backend1 retry=0
            BalancerMember http://backend2 retry=0
          &lt;/Proxy>
          ProxyPass         /    balancer://cluster/
          ProxyPassReverse  /    balancer://cluster/
        '';
      networking.firewall.allowedTCPPorts = [ 80 ];
    };

  backend1 = backend;
  backend2 = backend;
}
</programlisting>
</example>

<para>To deploy it, we need a physical specification, shown in <xref
linkend="ex-physical-multi.nix" />.  Deployment is as follows:

<screen>
$ nixops create ./load-balancer.nix ./load-balancer-vbox.nix -d load-balancer-vbox
$ nixops deploy -d load-balancer-vbox
</screen>

Note that NixOps creates and deploys the VMs in parallel to speed
things up.</para>

<example xml:id="ex-physical-multi.nix">
  <title><filename>load-balancer-vbox.nix</filename>: VirtualBox physical network specification</title>
<programlisting>
let
  vbox = { deployment.targetEnv = "virtualbox"; };
in
{ proxy    = vbox;
  backend1 = vbox;
  backend2 = vbox;
}
</programlisting>
</example>

</section>

</section>

<section xml:id="sec-deploying-to-physical-nixos"><title>Deploying to a NixOS machine</title>

<para>To deploy to a machine that is already running NixOS, simply set
<varname>deployment.targetHost</varname> to the IP address or host name of the machine,
and leave <varname>deployment.targetEnv</varname> undefined.
See <xref linkend="ex-physical-nixos.nix" />.
</para>

<example xml:id="ex-physical-nixos.nix">
  <title><filename>trivial-nixos.nix</filename>: NixOS target physical network specification</title>
<programlisting>
{
  webserver =
    { config, pkgs, ... }:
    { deployment.targetHost = "1.2.3.4";
    };
}
</programlisting>
</example>

</section>

<!--

<para>EC2 logical.nix</para>

<para>EC2 deployment</para>

<para>Multiple machines (load balancer)</para>

-->

</chapter>
